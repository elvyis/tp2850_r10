C51 COMPILER V9.56.0.0   XMODEM                                                            06/23/2021 11:51:34 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE XMODEM
OBJECT MODULE PLACED IN .\obj\xmodem.obj
COMPILER INVOKED BY: C:\Program Files\C51\BIN\C51.EXE src\xmodem.c LARGE OPTIMIZE(9,SIZE) BROWSE DEBUG OBJECTEXTEND PRIN
                    -T(.\lst\xmodem.lst) TABS(2) OBJECT(.\obj\xmodem.obj)

line level    source

   1          /*  
   2           * Copyright 2001-2010 Georges Menie (www.menie.org)
   3           * All rights reserved.
   4           * Redistribution and use in source and binary forms, with or without
   5           * modification, are permitted provided that the following conditions are met:
   6           *
   7           *     * Redistributions of source code must retain the above copyright
   8           *       notice, this list of conditions and the following disclaimer.
   9           *     * Redistributions in binary form must reproduce the above copyright
  10           *       notice, this list of conditions and the following disclaimer in the
  11           *       documentation and/or other materials provided with the distribution.
  12           *     * Neither the name of the University of California, Berkeley nor the
  13           *       names of its contributors may be used to endorse or promote products
  14           *       derived from this software without specific prior written permission.
  15           *
  16           * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND ANY
  17           * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  18           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  19           * DISCLAIMED. IN NO EVENT SHALL THE REGENTS AND CONTRIBUTORS BE LIABLE FOR ANY
  20           * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  21           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  22           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  23           * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  24           * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  25           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  26           */
  27          
  28          /* this code needs standard functions memcpy() and memset()
  29             and input/output functions _inbyte() and _outbyte().
  30          
  31             the prototypes of the input/output functions are:
  32               int _inbyte(unsigned short timeout); // msec timeout
  33               void _outbyte(int c);
  34          
  35           */
  36          #include <stdio.h>
  37          #include <string.h>
  38          #include "inc\Config.h"
  39          #include "inc\reg.h"
  40          #include "inc\typedefs.h"
  41          #include "inc\main.h"
  42          #include "inc\printf.h"
  43          #include "crc16.h"
  44          #include "inc\tp2825.h"
  45          
  46          #define SOH  0x01
  47          #define STX  0x02
  48          #define EOT  0x04
  49          #define ACK  0x06
  50          #define NAK  0x15
  51          #define CAN  0x18
  52          #define CTRLZ 0x1A
  53          
  54          #define DLY_1S 200
C51 COMPILER V9.56.0.0   XMODEM                                                            06/23/2021 11:51:34 PAGE 2   

  55          #define MAXRETRANS 5
  56          //#define _inbyte(timeout) RS_rx()
  57          #define _outbyte(c) RS_tx(c)
  58          
  59          extern xdata BYTE PTZ_buf[16];
  60          
  61          int _inbyte(unsigned int cnt)
  62          {
  63   1              while(cnt)
  64   1              {
  65   2                if( RS_ready()) return (WORD)RS_rx();
  66   2                delay(1); //5ms
  67   2                cnt--;
  68   2              }
  69   1              return -1;        
  70   1      }
  71          static int check(int crc, const unsigned char *buf, int sz)
  72          {
  73   1        if (crc) {
  74   2          unsigned short crc = crc16_ccitt(buf, sz);
  75   2          unsigned short tcrc = (buf[sz]<<8)+buf[sz+1];
  76   2          if (crc == tcrc)
  77   2            return 1;
  78   2        }
  79   1        else {
  80   2          int i;
  81   2          unsigned char cks = 0;
  82   2          for (i = 0; i < sz; ++i) {
  83   3            cks += buf[i];
  84   3          }
  85   2          if (cks == buf[sz])
  86   2          return 1;
  87   2        }
  88   1      
  89   1        return 0;
  90   1      }
  91          
  92          static void flushinput(void)
  93          {
  94   1        while (_inbyte(((DLY_1S)*3)>>1) >= 0)
  95   1          ;
  96   1      }
  97          void utc_end(void)
  98          {
  99   1        MonTX(0x8d,0x00,0x00,0x00,0x00);  
 100   1      }
 101          //int xmodemReceive(unsigned char *dest, int destsz)
 102          int xmodemReceive(unsigned char data_type)
 103          {
 104   1        unsigned char xbuff[134]; /* 128 for XModem  + 3 head chars + 2 crc + nul */
 105   1        unsigned char *p;
 106   1        //unsigned char data_type;
 107   1        int bufsz, crc = 0;
 108   1        unsigned char trychar = 'C';
 109   1        unsigned char packetno = 1;
 110   1        int i, c, len = 0;
 111   1        unsigned char tryno,retry, retrans = MAXRETRANS;
 112   1      /*
 113   1                    ptz.cmd     = 0x89;
 114   1                  ptz.data[0] = 0xa0; //
 115   1      
 116   1        */
C51 COMPILER V9.56.0.0   XMODEM                                                            06/23/2021 11:51:34 PAGE 3   

 117   1        MonTX(0x89,0xa0,0x55,0xaa,00); //check camera 
 118   1        if(MonRX()) 
 119   1        {
 120   2          Printf("unsupported!\r\n");
 121   2          return -4;
 122   2        }
 123   1        else
 124   1        {
 125   2          if((0x89 == PTZ_buf[2]))
 126   2           {
 127   3             Printf("ISP %x, Sensor %x, VER %x\r\n", (WORD)PTZ_buf[4],(WORD)PTZ_buf[5],(WORD)PTZ_buf[6]);
 128   3           }
 129   2        }
 130   1        delay(10);
 131   1        
 132   1        if(data_type == USER_DATA_UPDATE) //user data
 133   1        {
 134   2          MonTX(0x8d,data_type,0x08,0x00,BLOCK_LENGTH/16); //user data 1K=8x8x16
 135   2        }
 136   1        else if(data_type == FIRMWARE_UPDATE) //firmware
 137   1        {
 138   2          MonTX(0x8d,data_type,0xe0,0x01,BLOCK_LENGTH/16); //firmware 60K=480x8x16
 139   2          //delay(20);
 140   2        }
 141   1        else if(data_type == FONT_UPDATE) //font
 142   1        {
 143   2          MonTX(0x8d,data_type,0x7e,0x01,BLOCK_LENGTH/16); //font data 48K=382x8x16
 144   2          //delay(20);
 145   2        } 
 146   1        else
 147   1        {
 148   2          Printf("unknown data!\r\n");
 149   2          utc_end();
 150   2          return -5;    
 151   2        }
 152   1      
 153   1        if(MonRX()) 
 154   1        {
 155   2          Printf("no respond!\r\n");
 156   2          utc_end();
 157   2          return -6;
 158   2        }
 159   1        else
 160   1        {
 161   2           //if((0x89 == PTZ_buf[2]) && (0xa0 == PTZ_buf[3]))
 162   2           //{
 163   2          //   Printf("ISP %x, Sensor %x, VER %x\r\n", (WORD)PTZ_buf[4],(WORD)PTZ_buf[5],(WORD)PTZ_buf[6]);
 164   2          // }
 165   2        }   
 166   1        delay(10);
 167   1        
 168   1        for(;;) {
 169   2          for( retry = 0; retry < 16; ++retry) {
 170   3            if (trychar) _outbyte(trychar);
 171   3            if ((c = _inbyte((DLY_1S)<<1)) >= 0) {
 172   4              switch (c) {
 173   5              case SOH:
 174   5                bufsz = 128;
 175   5                goto start_recv;
 176   5              //case STX:
 177   5              //  bufsz = 1024;
 178   5              //  goto start_recv;
C51 COMPILER V9.56.0.0   XMODEM                                                            06/23/2021 11:51:34 PAGE 4   

 179   5              case EOT:
 180   5                flushinput();
 181   5                _outbyte(ACK);
 182   5                utc_end();        
 183   5                return len; /* normal end */
 184   5              case CAN:
 185   5                if ((c = _inbyte(DLY_1S)) == CAN) {
 186   6                  flushinput();
 187   6                  _outbyte(ACK);
 188   6                  utc_end();
 189   6                  return -1; /* canceled by remote */
 190   6                }
 191   5                break;
 192   5              default:
 193   5                break;
 194   5              }
 195   4            }
 196   3          }
 197   2          if (trychar == 'C') { trychar = NAK; continue; }
 198   2          flushinput();
 199   2          _outbyte(CAN);
 200   2          _outbyte(CAN);
 201   2          _outbyte(CAN);
 202   2          utc_end();
 203   2          return -2; /* sync error */
 204   2      
 205   2        start_recv:
 206   2          if (trychar == 'C') crc = 1;
 207   2          trychar = 0;
 208   2          p = xbuff;
 209   2          *p++ = c;
 210   2          for (i = 0;  i < (bufsz+(crc?1:0)+3); ++i) {
 211   3            if ((c = _inbyte(DLY_1S)) < 0) goto reject;
 212   3            //c = _inbyte(DLY_1S);
 213   3            *p++ = c;
 214   3          }
 215   2      
 216   2          if (xbuff[1] == (unsigned char)(~xbuff[2]) && 
 217   2            (xbuff[1] == packetno || xbuff[1] == (unsigned char)packetno-1) &&
 218   2            check(crc, &xbuff[3], bufsz)) {
 219   3            if (xbuff[1] == packetno) {
 220   4              /*register int count = destsz - len;
 221   4              if (count > bufsz) count = bufsz;
 222   4              if (count > 0) {
 223   4                memcpy (&dest[len], &xbuff[3], count);
 224   4                len += count; tcrc = (buf[sz]<<8)+buf[sz+1];
 225   4              }*/
 226   4      
 227   4              tryno = 5;
 228   4              while(tryno)
 229   4              {
 230   5                MonTX(0x8a,data_type,packetno-1,xbuff[bufsz+3],xbuff[bufsz+4]);
 231   5              //delay(20); //50ms
 232   5              //MonRX();
 233   5      //          WaitRX(0xaa,0x55);          
 234   5                BurstTX(&xbuff[3]);
 235   5                //delay(20); //50ms
 236   5                //MonRX();
 237   5                if(WaitRX(xbuff[bufsz+3],xbuff[bufsz+4])) break;
 238   5                tryno--;
 239   5              }
 240   4              
C51 COMPILER V9.56.0.0   XMODEM                                                            06/23/2021 11:51:34 PAGE 5   

 241   4              if(tryno)
 242   4              { 
 243   5                ++packetno;
 244   5                retrans = MAXRETRANS+1;
 245   5              }
 246   4              else
 247   4              {
 248   5                retrans = 0;
 249   5              }
 250   4            }
 251   3            if (--retrans <= 0) {
 252   4              flushinput();
 253   4              _outbyte(CAN);
 254   4              _outbyte(CAN);
 255   4              _outbyte(CAN);
 256   4              utc_end();
 257   4              return -3; /* too many retry error */
 258   4            }
 259   3            _outbyte(ACK);
 260   3            continue;
 261   3          }
 262   2        reject:
 263   2          flushinput();
 264   2          _outbyte(NAK);
 265   2        }
 266   1      }
 267          
 268          #if(0) 
              int xmodemTransmit(unsigned char *src, int srcsz)
              {
                unsigned char xbuff[134]; /* 128 for XModem + 3 head chars + 2 crc + nul */
                int bufsz, crc = -1;
                unsigned char packetno = 1;
                int i, c, len = 0;
                int retry;
              
                for(;;) {
                  for( retry = 0; retry < 16; ++retry) {
                    if ((c = _inbyte((DLY_1S)<<1)) >= 0) {
                      switch (c) {
                      case 'C':
                        crc = 1;
                        goto start_trans;
                      case NAK:
                        crc = 0;
                        goto start_trans;
                      case CAN:
                        if ((c = _inbyte(DLY_1S)) == CAN) {
                          _outbyte(ACK);
                          flushinput();
                          return -1; /* canceled by remote */
                        }
                        break;
                      default:
                        break;
                      }
                    }
                  }
                  _outbyte(CAN);
                  _outbyte(CAN);
                  _outbyte(CAN);
                  flushinput();
C51 COMPILER V9.56.0.0   XMODEM                                                            06/23/2021 11:51:34 PAGE 6   

                  return -2; /* no sync */
              
                  for(;;) {
                  start_trans:
                    xbuff[0] = SOH; bufsz = 128;
                    xbuff[1] = packetno;
                    xbuff[2] = ~packetno;
                    c = srcsz - len;
                    if (c > bufsz) c = bufsz;
                    if (c >= 0) {
                      memset (&xbuff[3], 0, bufsz);
                      if (c == 0) {
                        xbuff[3] = CTRLZ;
                      }
                      else {
                        memcpy (&xbuff[3], &src[len], c);
                        if (c < bufsz) xbuff[3+c] = CTRLZ;
                      }
                      if (crc) {
                        unsigned short ccrc = crc16_ccitt(&xbuff[3], bufsz);
                        xbuff[bufsz+3] = (ccrc>>8) & 0xFF;
                        xbuff[bufsz+4] = ccrc & 0xFF;
                      }
                      else {
                        unsigned char ccks = 0;
                        for (i = 3; i < bufsz+3; ++i) {
                          ccks += xbuff[i];
                        }
                        xbuff[bufsz+3] = ccks;
                      }
                      for (retry = 0; retry < MAXRETRANS; ++retry) {
                        for (i = 0; i < bufsz+4+(crc?1:0); ++i) {
                          _outbyte(xbuff[i]);
                        }
                        if ((c = _inbyte(DLY_1S)) >= 0 ) {
                          switch (c) {
                          case ACK:
                            ++packetno;
                            len += bufsz;
                            goto start_trans;
                          case CAN:
                            if ((c = _inbyte(DLY_1S)) == CAN) {
                              _outbyte(ACK);
                              flushinput();
                              return -1; /* canceled by remote */
                            }
                            break;
                          case NAK:
                          default:
                            break;
                          }
                        }
                      }
                      _outbyte(CAN);
                      _outbyte(CAN);
                      _outbyte(CAN);
                      flushinput();
                      return -4; /* xmit error */
                    }
                    else {
                      for (retry = 0; retry < 10; ++retry) {
                        _outbyte(EOT);
C51 COMPILER V9.56.0.0   XMODEM                                                            06/23/2021 11:51:34 PAGE 7   

                        if ((c = _inbyte((DLY_1S)<<1)) == ACK) break;
                      }
                      flushinput();
                      return (c == ACK)?len:-5;
                    }
                  }
                }
              }
              #endif
 374          
 375          #ifdef TEST_XMODEM_RECEIVE
              int main(void)
              {
                int st;
              
                printf ("Send data using the xmodem protocol from your terminal emulator now...\n");
                /* the following should be changed for your environment:
                   0x30000 is the download address,
                   65536 is the maximum size to be written at this address
                 */
                st = xmodemReceive((char *)0x30000, 65536);
                if (st < 0) {
                  printf ("Xmodem receive error: status: %d\n", st);
                }
                else  {
                  printf ("Xmodem successfully received %d bytes\n", st);
                }
              
                return 0;
              }
              #endif
 396          #ifdef TEST_XMODEM_SEND
              int main(void)
              {
                int st;
              
                printf ("Prepare your terminal emulator to receive data now...\n");
                /* the following should be changed for your environment:
                   0x30000 is the download address,
                   12000 is the maximum size to be send from this address
                 */
                st = xmodemTransmit((char *)0x30000, 12000);
                if (st < 0) {
                  printf ("Xmodem transmit error: status: %d\n", st);
                }
                else  {
                  printf ("Xmodem successfully transmitted %d bytes\n", st);
                }
              
                return 0;
              }
              #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1106    ----
   CONSTANT SIZE    =     73    ----
   XDATA SIZE       =   ----     166
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
C51 COMPILER V9.56.0.0   XMODEM                                                            06/23/2021 11:51:34 PAGE 8   

END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
