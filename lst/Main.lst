C51 COMPILER V9.60.7.0   MAIN                                                              12/22/2023 18:00:40 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\obj\Main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE src\Main.c LARGE OPTIMIZE(9,SIZE) BROWSE DEBUG OBJECTEXTEND PRINT(.\lst\
                    -Main.lst) TABS(2) OBJECT(.\obj\Main.obj)

line level    source

   1          //****************************************************************/
   2          /*                                                                            */
   3          /*                     HD encocer & decoder boards of Vertex6                             */
   4          /*                                                                            */
   5          /****************************************************************/
   6          
   7          #include <stdio.h>
   8          #include <string.h>
   9          #include "inc\Config.h"
  10          #include "inc\reg.h"
  11          #include "inc\typedefs.h"
  12          #include "inc\main.h"
  13          #include "inc\i2c.h"
  14          #include "inc\printf.h"
  15          #include "inc\Coaxitron.h"
  16          
  17          #include "inc\TP2825.h"
  18          #include "inc\isp_reg.h"
  19          
  20          bit   I2CInitialBlocking = 1;
  21          bit   DetAutoRes = 0;
  22          bit   MDIN_debug = 0;
  23          bit   half_scaler = 0;
  24          bit   en_tvi960p_H1400=0;
  25          bit   DetAutoStd = 1;
  26          bit   BT1120_out = 0;
  27          bit   en_960P = 0;
  28          bit   g_uart0_flag = 0;
  29          bit   BYDtest = 0;
  30          xdata BYTE  ManVidRes;
  31          xdata BYTE  ManVidStd;
  32          xdata BYTE  ManSelCh;
  33          xdata BYTE  IsChannel;
  34          
  35          #ifdef TEST_SERCOM
  36          bit   MaskEcho = 0;
  37          xdata BYTE  StoreArg1 = 0, StoreArg2 = 0;
  38          xdata BYTE  AddressOffset = 0;
  39          #endif //TEST_SERCOM
  40          xdata WORD    tm01=0;
  41          xdata BYTE    tm02=0;
  42          xdata BYTE  mS_timer;
  43          xdata BYTE    tic01=0;
  44          xdata BYTE    tic02=0;
  45          xdata BYTE  tic_rs485=0;
  46          xdata BYTE  I2CAddressDeb;
  47          xdata BYTE  TVII2CAddress;
  48              bit timeout=1;
  49          
  50          
  51          extern xdata BYTE cam_ch;
  52          extern CODE PelcoD_cmd PelcoD_cmd_dataset[];
  53          extern xdata BYTE locked[];
  54          //extern BYTE Det_VideoLoss(BYTE);
C51 COMPILER V9.60.7.0   MAIN                                                              12/22/2023 18:00:40 PAGE 2   

  55          extern void EQ_Detect();
  56          extern void MDIN340(void);
  57          extern void CreateMDIN340VideoInstance(void);
  58          extern int xmodemReceive(unsigned char data_type);
  59          
  60          //===================== Serial ============================================
  61          #define BUF_MAX   134
  62          static  xdata BYTE  RS_buf[BUF_MAX];
  63          static  xdata BYTE   RS_in=0, RS_out=0;
  64              bit         RS_Xbusy=0;     // bit RS_Xbusy=0;
  65          
  66          //================== Debug key input ======================================
  67          #define MaxBuf    20           
  68          #define MaxArg    8         
  69          static  xdata BYTE  commdbuf[MaxBuf];
  70          static  xdata BYTE  commdptr;
  71          static  xdata BYTE    bptr;
  72          static  xdata BYTE  arg[MaxArg], argn;  
  73          //================== PTZ =================================================
  74          
  75          #define   isr_timer0_on()   (ET0=1)
  76          #define   isr_timer1_on()   (ET1=1)
  77          #define   isr_timer2_on()   (ET2=1)
  78          #define   isr_uart0_on()    (ES=1)
  79          #define   isr_uart1_on()    (ES1=1)
  80          #define   isr_ext0_on()   (EX0=1)
  81          #define   isr_ext1_on()   (EX1=1)
  82          #define   isr_global_on()   (EA=1)
  83          #define   isr_i2c_on()    (EINT3=1)
  84          #define   timer0_start()    (TR0=1)
  85          #define   timer1_start()    (TR1=1)
  86          #define   isr5_tp2801_on()    (EINT5=1)
  87          /*****************************************************************************/
  88          /*      INT 0 Interrupt                                                    */
  89          /*****************************************************************************/
  90          INTERRUPT(0, int0_int)
  91          {
  92   1        EX0 = 0;
  93   1        //g_vsync_flag = 1;
  94   1      
  95   1        EX0 = 1;
  96   1      
  97   1      }
  98          
  99          
 100          /*****************************************************************************/
 101          /*      Timer 0 Interrupt                                                    */
 102          /*****************************************************************************/
 103          INTERRUPT(1, timer0_int)
 104          {
 105   1        EA = 0;
 106   1        
 107   1        tm01++;           //9600Hz(104us)
 108   1        tm02++;
 109   1        tic_rs485++;
 110   1      
 111   1        #ifdef CLOCK_11M
                if( tm01 > 48 ) {     // 5msec
                #elif defined CLOCK_22M
 114   1        if( tm01 > 48*2 ) {   
 115   2        #endif
 116   2        
C51 COMPILER V9.60.7.0   MAIN                                                              12/22/2023 18:00:40 PAGE 3   

 117   2          tm01 = 0;
 118   2            tic01++;
 119   2          if(tic02)
 120   2          {
 121   3            tic02--;  
 122   3          }
 123   2          else
 124   2          {
 125   3            timeout = 1;
 126   3          } 
 127   2        }
 128   1        if(tm02 > 10)
 129   1        {
 130   2          tm02 = 0;
 131   2          if(mS_timer) mS_timer--;
 132   2        }
 133   1        EA = 1;
 134   1      }
 135          void  EX1_int(void) interrupt 2   // I2C Interrupt
 136          {
 137   1        EA = 0;
 138   1      
 139   1        EA = 1;
 140   1      } 
 141          void wait_5ms(BYTE cnt)   //5ms period
 142          {
 143   1        ET0 = 0;
 144   1        timeout = 0;
 145   1        tic02 = cnt;
 146   1        ET0 = 1;
 147   1      }
 148          /*****************************************************************************/
 149          /*      Timer 1 Interrupt                                                    */
 150          /*****************************************************************************/
 151          /*
 152          INTERRUPT(5, timer2_int)
 153          {
 154            ET2 = 0;    //disable interrupt timer2
 155            
 156            tic_rs485++;
 157            
 158            TF2 = 0;    //clear interrupt flag
 159            ET2 = 1;    //enable interrupt timer2
 160          }
 161          */
 162          
 163          void delay(BYTE cnt)    //5ms period
 164          {
 165   1        BYTE t;
 166   1      
 167   1        if( !cnt ) return;
 168   1      
 169   1        t = tic01 + cnt;
 170   1        while( tic01 != t );
 171   1      }
 172          
 173          //****************************************************************************/
 174          //      Serial Interrupt                                                   
 175          //****************************************************************************/
 176          INTERRUPT(4, serial_int)
 177          {
 178   1        EA = 0;
C51 COMPILER V9.60.7.0   MAIN                                                              12/22/2023 18:00:40 PAGE 4   

 179   1      #if 1 
 180   1        if( RI ) {          //--- Receive interrupt ----
 181   2          RI = 0;
 182   2          RS_buf[RS_in++] = SBUF;
 183   2          if( RS_in>=BUF_MAX ) RS_in = 0;
 184   2        }
 185   1      
 186   1        if( TI ) {          //--- Transmit interrupt ----
 187   2          TI = 0;
 188   2          RS_Xbusy=0;
 189   2        }
 190   1      #else
                if(g_uart0_flag == 0)
                {
              //    g_rx_buf[g_wr_index++] = SBUF;
              //    if(g_wr_index == UART_RBUF_MAX)
              //      g_wr_index = 0;
              //    else  ;
                  RS_buf[RS_in++] = SBUF;
                  if( RS_in>=BUF_MAX ) RS_in = 0;   
                  //RI = 0;
                }
                else  ;
                RI = 0;
                TI = 0;
                g_uart0_flag = 0; 
              #endif
 206   1        EA = 1;
 207   1      }
 208          void i2c_int(void) interrupt 9
 209          {
 210   1        EA = 0;
 211   1        EXIF = 0;
 212   1        //g_i2c_flag = YES;
 213   1        EA = 1;
 214   1      }
 215          
 216          void tp2801_int5(void) interrupt 11
 217          {
 218   1        EA = 0;
 219   1        EXIF = 0;
 220   1        //g_2801_int5_flag=1;
 221   1        
 222   1        EA = 1;
 223   1      }
 224          //=============================================================================
 225          //    Serial RX Check                            
 226          //=============================================================================
 227          BYTE RS_ready(void)
 228          {
 229   1        if( RS_in == RS_out ) return 0;
 230   1        else return 1;
 231   1      }
 232          //=============================================================================
 233          //    Serial RX                              
 234          //=============================================================================
 235          BYTE RS_rx(void)
 236          {
 237   1        BYTE  ret;
 238   1          
 239   1        //ES = 0;
 240   1        ret = RS_buf[RS_out];
C51 COMPILER V9.60.7.0   MAIN                                                              12/22/2023 18:00:40 PAGE 5   

 241   1        RS_out++;
 242   1        if(RS_out >= BUF_MAX) 
 243   1          RS_out = 0;
 244   1        //ES = 1;
 245   1      
 246   1        return ret;
 247   1      }
 248          //=============================================================================
 249          //    Serial TX                              
 250          //=============================================================================
 251          void RS_tx(BYTE tx_buf)
 252          {
 253   1      #if 1 
 254   1        while(1) {
 255   2          if(!RS_Xbusy) {
 256   3            SBUF = tx_buf;
 257   3            RS_Xbusy=1;
 258   3            break;
 259   3          }
 260   2        }
 261   1      #else
                //g_uart0_flag = 1; //TX_FLAG;
                SBUF = tx_buf;
                //while(g_uart0_flag) ;
                delay1(20);
              #endif  
 267   1      }
 268          void timer_init(void)
 269          {
 270   1        // timer 0 : mode 1
 271   1        TMOD = 0x21;
 272   1      
 273   1        // timer 0 : 10ms period..
 274   1        // 24M/12 = 2M
 275   1        // 20,000 / 2M = 10 ms, 0x10000 - 20000 = 0xB1E0
 276   1        //TH0 = 0xB1;   //=0x63
 277   1        //TL0 = 0xE0;   //=0xC0
 278   1        // 200 / 2M = 100 us, 0x10000 - 200 = 0xff38
 279   1        TH0 = 0xff;   //=0x63
 280   1        TL0 = 0x38;   //=0xC0
 281   1        IE = 0x82;
 282   1      }
 283          void uart0_init(void)
 284          {
 285   1        PCON = 0x80 ;   //Double baud rate when Timer1 is used=PCON.7
 286   1        SCON = 0x50 ;   //8bit UART, Baud rate is variable=SCON.6
 287   1                        //Receiver Enable=SCON.4
 288   1        TMOD = 0x21 ;   //8bit auto reload counter=TMOD.5
 289   1                        //16bit counter=TMOD.0 (Timer0 mode1)
 290   1        TH1  = 0xF3 ;   // 0xF3:9600 (24MHz) -> 0xE6:9600(48MHz)
 291   1                        // TH1=256-(2x48x1000000)/(384x9600)
 292   1      //  TH1  = 0xE6 ;   // 0xF3:9600 (24MHz) -> 0xE6:9600(48MHz)
 293   1        timer1_start();
 294   1      }
 295          /*===========================================================================*/
 296          /*        Initialize CPU                                                     */
 297          /*===========================================================================*/
 298            
 299          void InitCPU(void)
 300          {
 301   1        
 302   1      PCON = 0x80;    // 0000 0000 SMOD(double baud rate bit) = 1   
C51 COMPILER V9.60.7.0   MAIN                                                              12/22/2023 18:00:40 PAGE 6   

 303   1        
 304   1      //  TH1 = 0xf0;
 305   1        SCON = 0x50;    // 0100 0000 mode 1 - 8 bit UART        
 306   1                  // Enable serial reception            
 307   1          TMOD = 0x22;    // 0010 0010 timer 0 - 8 bit auto reload    
 308   1                  // timer 1 - baud rate generator        
 309   1          TCON = 0x55;    // 0101 0001 timer 0,1 run            
 310   1                  // int 0,  edge triggered           
 311   1                  // int 1,  edge triggered           
 312   1                  // TF1 TR1 TF0 TR0  EI1 IT1 EI0 IT0       
 313   1      //  TH0 = TL0 = 64;   // 64=4608 Hz at 11.0592MHz
 314   1                  // 64=4800Hz at 11.0592MHz (11.0592/12)/192=4800Hz. (255-64+1=192)
 315   1                  
 316   1      //  TH0 = TL0 = 160;  // 160=9600Hz at 11.0592MHz (11.0592/12)/96=9600Hz. (255-160+1=96)
 317   1        TH0 = TL0 = 100; //100; // 160=9600Hz at 11.0592MHz (11.0592/12)/96=9600Hz. (255-160+1=96)
 318   1        TH1  = 0xF3;    // 19200
 319   1                  
 320   1        
 321   1        IP   = 0x02;    // 0000 0000 interrupt priority         
 322   1                  // -  - PT2 PS PT1 PX1 PT0 PX0               
 323   1        IE   = 0x82;    // 1001 0010 interrupt enable:Serial,TM0      
 324   1                  // EA - ET2 ES ET1 EX1 ET0 EX0  
 325   1      
 326   1      
 327   1        TI   = 1;     
 328   1        ES   = 1;   
 329   1        
 330   1      I2CTP = 0x03; //1;  //4;  //0x0a; // i2c timer period
 331   1      
 332   1        XBYTE[rGPC_DIR] = 0x7e;   //1->input 0->output  
 333   1        XBYTE[rGPC_CTRL] = 0x07;  //GPIOC0~2(P2) as GPIO  
 334   1        
 335   1        XBYTE[rGPD_DIR] = 0xf8;   //1->input 0->output   
 336   1        XBYTE[rGPD_CTRL] = 0x0f;   //GPIOD4~7(P3) as GPIO
 337   1        
 338   1        RI=0; TI=0; TF0=0;
 339   1      }
 340          /*===========================================================================*/
 341          /*    New Line                                   */
 342          /*===========================================================================*/
 343          void NewLine(void)
 344          {
 345   1        Puts("\r\n"); 
 346   1      }
 347          
 348          void PutsP(DATA_P BYTE *ptr)
 349          {
 350   1        BYTE ch;
 351   1        while(*ptr!='\0') {
 352   2          ch = *ptr++;
 353   2          RS_tx(ch);
 354   2        }
 355   1      }
 356          
 357          /*===========================================================================*/
 358          /*    Prompt                                                         */
 359          /*===========================================================================*/
 360          void Prompt(void)
 361          {
 362   1        Printf("\r\nI2C[%02x]>", (WORD)I2CAddressDeb);
 363   1      }
 364          /*===========================================================================*/
C51 COMPILER V9.60.7.0   MAIN                                                              12/22/2023 18:00:40 PAGE 7   

 365          /*    I2C Edit Read                                                    */
 366          /*===========================================================================*/
 367          
 368          void MonWriteI2C(BYTE addr, BYTE index, BYTE val) 
 369          {
 370   1        Printf("\r\nWrite %02xh to [Adrs(%02xh)Index(%02xh)]", (WORD)val, (WORD)addr, (WORD)index);
 371   1        I2C_byte_write(addr, index, val);
 372   1      }
 373          /*
 374          void Montp28xx_byte_writen_(BYTE addr, BYTE *val, BYTE cnt) 
 375          {
 376            BYTE i;
 377          
 378            Printf("Write ");
 379            for(i=0; i<cnt; i++) {
 380              Printf("%02xh ", val[i]);
 381            }
 382            Printf("to [Adrs(%02xh)", (WORD)addr);
 383            if( !tp28xx_byte_writen_(addr, val, cnt) )    //LJY001127
 384              Puts("---> Fail!! "); 
 385          }
 386          */
 387          /*===========================================================================*/
 388          /*    I2C Edit Read                                                    */
 389          /*===========================================================================*/
 390          BYTE MonReadI2C(BYTE addr, BYTE index)
 391          {
 392   1        BYTE val;
 393   1      
 394   1        val = I2C_byte_read(addr, index);
 395   1        Printf("Read [Adrs:%02xh,%02xh] %02xh", (WORD)addr, (WORD)index, (WORD)val);
 396   1      
 397   1        return val;
 398   1      }
 399          /*
 400          void MonReadI2Cmn(BYTE addr, BYTE *wrdata, BYTE argcnt)
 401          {
 402            BYTE i, rcnt;
 403          
 404            Printf("Read  [Adrs:%02xh ", (WORD)addr);
 405            for(i=0; i<argcnt-1; i++)
 406              Printf(" Index:%02xh ", wrdata[i] );
 407            Printf("] ");
 408          
 409            rcnt = wrdata[argcnt-1];
 410            ReadI2Cmn(addr, argcnt-1, rcnt, wrdata);
 411          
 412            for(i=0; i<rcnt; i++)
 413              Printf("%02xh ", (WORD)wrdata[i]);
 414          }
 415          
 416          BYTE MonReadI2C16(BYTE addr, BYTE indexH, BYTE indexL) 
 417          {
 418            WORD val;
 419          
 420            val = ReadI2C16(addr, indexH, indexL);
 421          
 422            Printf("Read [Adrs%02xh, %02x%02xh] %04xh",(WORD)addr, (WORD)indexH,(WORD)indexL,(WORD)val );
 423            return val;
 424          
 425          }
 426          
C51 COMPILER V9.60.7.0   MAIN                                                              12/22/2023 18:00:40 PAGE 8   

 427          void MonWriteI2C16(BYTE addr, BYTE indexH, BYTE indexL, BYTE valH, BYTE valL) 
 428          {
 429            Printf("\r\nWrite %02x%02xh to [Adrs(%02xh)Index(%02x%02xh)]", (WORD)valH, (WORD)valL, (WORD)addr, (WORD)
             -indexH, (WORD)indexL);
 430            WriteI2C16(addr, indexH, indexL, valH, valL);
 431          }
 432          */
 433          /*===========================================================================*/
 434          /*    Convert ASCII to Binery                                              */
 435          /*===========================================================================*/
 436          BYTE Asc1Bin(BYTE asc)
 437          {
 438   1        if(asc>='0' && asc <='9') return (asc - '0');
 439   1        else if(asc>='a' && asc <='f') return (asc - 'a' + 0x0a);
 440   1        else if(asc>='A' && asc <='F') return (asc - 'A' + 0x0a);
 441   1        else return 0xff;
 442   1      }
 443          
 444          BYTE Asc2Bin(DATA_P BYTE *s)
 445          {
 446   1        BYTE bin;
 447   1        BYTE bin0;
 448   1      
 449   1        bin = 0;
 450   1        while(*s != '\0' && *s !=' ') {
 451   2          bin = bin<<4;
 452   2          if((bin0=Asc1Bin(*s))==0xff)
 453   2            return 0xff;
 454   2          bin = bin + bin0;
 455   2          s++;
 456   2        }
 457   1        return (bin);
 458   1      }
 459          
 460          void I2CDeviceSet(BYTE addr, CODE_P BYTE *RegSet)
 461          {
 462   1        int cnt=0;
 463   1        BYTE index, val;
 464   1      
 465   1        // Output discription
 466   1        #ifdef TASKING
                while( *RegSet ) 
                  RS_tx( *RegSet++ );
                RegSet++;
                #endif
 471   1      
 472   1        while ( *RegSet != 0xFF ) {
 473   2      /*    if( cnt==0 ) {
 474   2            addr = *RegSet;
 475   2      
 476   2            cnt = *(RegSet+1);
 477   2            RegSet+=2;
 478   2          }
 479   2      */
 480   2          index = *RegSet;
 481   2          val = *(RegSet+1);
 482   2      //    MonWriteI2C(addr, index, val);
 483   2          tp28xx_byte_write(index, val);
 484   2      
 485   2      //    Puts("\r\n");
 486   2      
 487   2          RegSet+=2;
C51 COMPILER V9.60.7.0   MAIN                                                              12/22/2023 18:00:40 PAGE 9   

 488   2      
 489   2          cnt--;
 490   2        }
 491   1      
 492   1        delay(50);
 493   1      }
*** WARNING C280 IN LINE 460 OF src\Main.c: 'addr': unreferenced local variable
 494          
 495          
 496          /*===========================================================================*/
 497          /*    Help                                                       */
 498          /*===========================================================================*/
 499          void Usage(void)
 500          {
 501   1        delay(2);
 502   1      
 503   1      
 504   1        Printf("\r\n+------- TP2825B/TP2850 board-Rev%d.%02x-----+", (WORD)FWVER/0x100, (WORD)FWVER%0x100);   
 505   1        
 506   1        Puts("\r\n| W Index Data [channel]   Write register                 |");  delay(1);
 507   1        Puts("\r\n| R Index [channel]        Read register                  |");  delay(1);
 508   1        Puts("\r\n| D Index Index            Dump registers                 |");  delay(1); 
 509   1        //Puts("\r\n| C Address                Change I2C Address             |");  delay(1); 
 510   1        //Puts("\r\n| < >                      Register++,Register--          |");  delay(1); 
 511   1        //Puts("\r\n| /                        Repeat previous command        |");  delay(1);
 512   1        Puts("\r\n| scanon/scanoff           enable/disable auto detection  |");  delay(1);
 513   1      //  Puts("\r\n+-----------------------------------------------+");  delay(1);   
 514   1      }
 515          
 516          /*
 517          BYTE Dec2Hex(BYTE val)
 518          {
 519            BYTE j =1;
 520            BYTE dat=0,rem;
 521          
 522            while(val != 0){
 523              rem = val%16;
 524              val = val/16;
 525              dat = dat + (rem*j);
 526          //    Printf("\r\nValue = %02d, remain = %02d, data = %02d",(WORD)val,(WORD)rem,(WORD)dat);
 527              j=j*10;
 528            }
 529          
 530          //  Printf("\r\nLast Value = %02d",(WORD)dat);
 531            return dat;
 532          
 533          }*/
 534          
 535          BYTE StringCommand()
 536          {
 537   1      BYTE *cmds[MaxBuf]  ;
 538   1      BYTE cnt = 0;
 539   1      BYTE cmd_ptr=0;
 540   1      bit eol;
 541   1      BYTE PTZ_cmd;
 542   1      BYTE pan_spd=0;
 543   1      BYTE tilt_spd=0;
 544   1      PelcoD_cmd PD_cmdset, *PD_cmd, *PD_cmd_sum;
 545   1      char ret; 
 546   1        PD_cmd_sum = &PD_cmdset;
 547   1        cmds[cmd_ptr++] = &commdbuf[commdptr];              //first string command
 548   1        
C51 COMPILER V9.60.7.0   MAIN                                                              12/22/2023 18:00:40 PAGE 10  

 549   1        while(commdbuf[commdptr]!=' '&& commdbuf[commdptr] != '\0'){        
 550   2          commdptr ++;
 551   2          cnt++;
 552   2        }
 553   1      
 554   1        if(cnt <= 1) {                          //one character command
 555   2          commdptr = 0;
 556   2          return 1;   
 557   2        } 
 558   1      
 559   1        if(commdbuf[commdptr] == '\0')                  //one string command
 560   1          eol = 1;
 561   1        else{                             //multi string command
 562   2          eol = 0;
 563   2            commdbuf[commdptr++] = '\0';
 564   2        }
 565   1      
 566   1        while(!eol){                          //subsidiarily string command
 567   2      
 568   2          if( commdbuf[commdptr]=='\0' ) {
 569   3              eol = 1; break;
 570   3          }
 571   2          else if(commdbuf[commdptr]==' ')
 572   2            commdbuf[commdptr++] = '\0';
 573   2      
 574   2          cmds[cmd_ptr++] = &commdbuf[commdptr];
 575   2          arg[++argn] = Asc2Bin(&commdbuf[commdptr]);
 576   2      
 577   2          while( commdbuf[commdptr]!=' ' && commdbuf[commdptr]!='\0' )
 578   2              commdptr++;
 579   2        }
 580   1      
 581   1        if((!strcmp(cmds[0],"I2C")) || (!strcmp(cmds[0],"i2c"))){
 582   2          Printf("\r\nI2C first string");
 583   2      
 584   2          if((!strcmp(cmds[1],"ON")) || (!strcmp(cmds[1],"on"))){
 585   3            Printf("\r\nI2C second string");
 586   3          }
 587   2        }
 588   1        else if((!strcmp(cmds[0],"SCANON")) || (!strcmp(cmds[0],"scanon"))){
 589   2        
 590   2            //MonTX(0x17,0x5f,0x00,0x00,0x00,0x00);
 591   2            DetAutoStd = 1;
 592   2        
 593   2        } 
 594   1        else if((!strcmp(cmds[0],"SCANOFF")) || (!strcmp(cmds[0],"scanoff"))){
 595   2        
 596   2            //MonTX(0x17,0x5f,0x00,0x00,0x00,0x00);
 597   2            DetAutoStd = 0;
 598   2          if(argn == 2)
 599   2          {
 600   3            Printf("\r\nsetvideo : %02x %02x", (WORD)arg[1],(WORD)arg[2]);
 601   3            Set_VidRes(arg[1], arg[2]);
 602   3          }
 603   2        }/*
 604   1        else if((!strcmp(cmds[0],"BYDTEST")) || (!strcmp(cmds[0],"bydtest"))){
 605   1        
 606   1            //MonTX(0x17,0x5f,0x00,0x00,0x00,0x00);
 607   1            BYDtest = 1;
 608   1        
 609   1        }*/ 
 610   1        else if((!strcmp(cmds[0],"MENU")) || (!strcmp(cmds[0],"menu"))){
C51 COMPILER V9.60.7.0   MAIN                                                              12/22/2023 18:00:40 PAGE 11  

 611   2        
 612   2            //MonTX(0x17,0x5f,0x00,0x00,0x00,0x00);
 613   2            Menu();
 614   2        
 615   2        }
 616   1        else if((!strcmp(cmds[0],"UP")) || (!strcmp(cmds[0],"up"))){
 617   2        
 618   2            //MonTX(0x06,0x00,0x00,0x00,0x00,0x00);
 619   2            Up();
 620   2        
 621   2        }
 622   1        else if((!strcmp(cmds[0],"DOWN")) || (!strcmp(cmds[0],"down"))){
 623   2        
 624   2            //MonTX(0x07,0x00,0x00,0x00,0x00,0x00);
 625   2            Down();
 626   2        
 627   2        }
 628   1        else if((!strcmp(cmds[0],"LEFT")) || (!strcmp(cmds[0],"left"))){
 629   2        
 630   2            //MonTX(0x09,0x00,0x00,0x00,0x00,0x00);
 631   2            Left();
 632   2        
 633   2        }
 634   1        else if((!strcmp(cmds[0],"RIGHT")) || (!strcmp(cmds[0],"right"))){
 635   2        
 636   2            //MonTX(0x08,0x00,0x00,0x00,0x00,0x00);
 637   2            Right();
 638   2        
 639   2        }
 640   1        else if((!strcmp(cmds[0],"RESET")) || (!strcmp(cmds[0],"reset"))){
 641   2        
 642   2            //MonTX(0x08,0x00,0x00,0x00,0x00,0x00);
 643   2          Reset();
 644   2        
 645   2        } 
 646   1        else if((!strcmp(cmds[0],"XR")) || (!strcmp(cmds[0],"xr"))){
 647   2        
 648   2          Printf("\r\nXR...");
 649   2          ret = -1;
 650   2          if((!strcmp(cmds[1],"DATA")) || (!strcmp(cmds[1],"data"))){
 651   3            Printf("user data ");
 652   3      //      ret=xmodemReceive(USER_DATA_UPDATE);
 653   3          } 
 654   2          else if((!strcmp(cmds[1],"FW")) || (!strcmp(cmds[1],"fw"))){
 655   3            Printf("firmware ");
 656   3      //      ret=xmodemReceive(FIRMWARE_UPDATE);
 657   3          }
 658   2      
 659   2          else if((!strcmp(cmds[1],"FONT")) || (!strcmp(cmds[1],"font"))){
 660   3            Printf("font ");
 661   3      //      ret=xmodemReceive(FONT_UPDATE);
 662   3          }
 663   2          
 664   2          if(ret >= 0) Printf("\r\nOK");
 665   2          else Printf("\r\nFail %d", ret);  
 666   2        
 667   2        }     
 668   1      
 669   1              
 670   1        else
 671   1            Puts(" <- Command Error!!");
 672   1        
C51 COMPILER V9.60.7.0   MAIN                                                              12/22/2023 18:00:40 PAGE 12  

 673   1      
 674   1        
 675   1        Prompt();
 676   1        commdptr = 0;
 677   1        commdbuf[0]='\0';
 678   1        
 679   1        return 0;
 680   1      
 681   1      }
*** WARNING C280 IN LINE 541 OF src\Main.c: 'PTZ_cmd': unreferenced local variable
*** WARNING C280 IN LINE 544 OF src\Main.c: 'PD_cmd': unreferenced local variable
 682          
 683          
 684          
 685          /*===========================================================================*/
 686          /*                Debug Command Service Routine                          */
 687          /*===========================================================================*/
 688          void DebugKeyIn(BYTE ikey)
 689          {
 690   1        BYTE i;
 691   1      
 692   1        #ifdef TEST_SERCOM
 693   1        #endif //TEST_SERCOM
 694   1      
 695   1        bit eol, cerror;
 696   1        static bit comment=0;
 697   1      
 698   1        //----- if end of loading -----
 699   1      
 700   1        //----- if comment, echo back and ignore -----
 701   1        if( comment ) {
 702   2          if( ikey=='\r' )
 703   2            comment = 0;
 704   2          else {
 705   3            RS_tx(ikey);
 706   3            return;
 707   3          }
 708   2        }
 709   1        else if( ikey==';' ) {
 710   2          comment = 1;
 711   2          RS_tx(ikey);
 712   2          return;
 713   2        }
 714   1      
 715   1        //----- Command Interpret ------------------------------
 716   1      
 717   1        if( (ikey=='\r') || (ikey=='/') ) {
 718   2          #ifdef TEST_SERCOM
 719   2          if(ikey=='\r')
 720   2            MaskEcho = 0;
 721   2          #endif //TEST_SERCOM
 722   2          comment = 0;
 723   2      
 724   2          if (ikey == '/') {      // Repeat 
 725   3            PutsP(commdbuf);
 726   3            commdptr = bptr;
 727   3            commdbuf[0]=arg[0];
 728   3          }
 729   2      
 730   2          commdbuf[commdptr] = '\0';
 731   2          
 732   2          bptr = commdptr;
C51 COMPILER V9.60.7.0   MAIN                                                              12/22/2023 18:00:40 PAGE 13  

 733   2          commdptr = 0;
 734   2          argn = 0;
 735   2          eol = 0;
 736   2          cerror = 0;
 737   2          
 738   2          while(commdbuf[commdptr]==' ') commdptr++;    // Cut leading space
 739   2          if (commdbuf[commdptr]=='\0'){
 740   3              eol = 1;                  // Exit, if null command
 741   3          }
 742   2          
 743   2        //  if(!StringCommand()) return;
 744   2      
 745   2        //  arg[argn++] = commdbuf[commdptr++];       // Get command
 746   2      
 747   2          arg[argn] = commdbuf[commdptr];   //Get first character
 748   2          if(!StringCommand()) return;
 749   2          argn++; commdptr++;
 750   2      
 751   2          while( !cerror && !eol ) {
 752   3            if( commdbuf[commdptr]!=' ' && commdbuf[commdptr]!='\0' ) {
 753   4              cerror = 1; break;
 754   4            }
 755   3      
 756   3            while( commdbuf[commdptr]==' ' ) commdptr++;
 757   3            if( commdbuf[commdptr]=='\0' ) {
 758   4              eol = 1; break;
 759   4            }
 760   3            arg[argn++] = Asc2Bin(&commdbuf[commdptr]);
 761   3            while( commdbuf[commdptr]!=' ' && commdbuf[commdptr]!='\0' ) {
 762   4              commdptr++;
 763   4            }
 764   3          }
 765   2      
 766   2          if(I2CInitialBlocking){ 
 767   3            cerror = 0;
 768   3            I2CInitialBlocking = 0;
 769   3          }
 770   2      
 771   2          if (cerror) {
 772   3            Puts(" <- Error!!");
 773   3            Prompt();
 774   3            commdptr = bptr = 0;
 775   3            return;
 776   3          }
 777   2      
 778   2          //----- Command ---------------------------
 779   2      
 780   2          
 781   2          switch(arg[0]) {
 782   3      /*
 783   3            case 'j':
 784   3            case 'J':
 785   3              if( argn==3 ) {
 786   3                NewLine();
 787   3                arg[2] = MonReadI2C16(I2CAddressDeb, arg[1], arg[2]);
 788   3              
 789   3              }
 790   3              break;
 791   3      
 792   3            case 'x':
 793   3            case 'X':
 794   3              if( argn > 4 ) {
C51 COMPILER V9.60.7.0   MAIN                                                              12/22/2023 18:00:40 PAGE 14  

 795   3                NewLine();
 796   3                MonWriteI2C16(I2CAddressDeb, arg[1], arg[2], arg[3], arg[4]);
 797   3              }
 798   3              break;
 799   3      */      
 800   3            case 'w':
 801   3            case 'W':
 802   3              if(argn == 3) {
 803   4      //          NewLine();
 804   4                MonWriteI2C(I2CAddressDeb, arg[1], arg[2]); 
 805   4                delay(1);
 806   4                MonReadI2C(I2CAddressDeb, arg[1]);
 807   4                
 808   4              }
 809   3      
 810   3              else if( argn == 4) {
 811   4                MonWriteI2C(I2CAddressDeb, 0x40, arg[3]); 
 812   4                delay(1);
 813   4                MonWriteI2C(I2CAddressDeb, arg[1], arg[2]);
 814   4                delay(1);
 815   4                MonReadI2C(I2CAddressDeb, arg[1]);        
 816   4              }
 817   3      
 818   3              break;
 819   3            
 820   3            case 'r':
 821   3            case 'R':
 822   3              if( argn==2 ) {
 823   4                NewLine();
 824   4                arg[2] = MonReadI2C(I2CAddressDeb, arg[1]);
 825   4              
 826   4              }
 827   3      
 828   3              else if( argn == 3) {
 829   4                MonWriteI2C(I2CAddressDeb, 0x40, arg[2]); 
 830   4                delay(1);
 831   4                MonReadI2C(I2CAddressDeb, arg[1]);
 832   4              }
 833   3      /*        
 834   3              else if( argn > 3 ) { // Read several Byte with several index.
 835   3                          // r cmd1 cmd2 ... rcnt
 836   3                          // ex) r 10 20 5
 837   3                          // read 5 bytes from index 1020.
 838   3                          // Useful for Z86129(CC Decorder).
 839   3                NewLine();
 840   3                MonReadI2Cmn(I2CAddressDeb, &arg[1], argn-1);
 841   3              }
 842   3      */
 843   3              break;
 844   3            
 845   3            case 'D':
 846   3            case 'd':
 847   3              if(argn == 1) {
 848   4                arg[1]+=8;
 849   4                arg[2] = arg[1]+7;
 850   4              }
 851   3              else if(argn == 2)
 852   3                arg[2] = arg[1]+7;
 853   3              for (i=arg[1]; i<=arg[2] && i<0xff; i++) {
 854   4                NewLine();
 855   4                MonReadI2C(I2CAddressDeb, i); 
 856   4              }
C51 COMPILER V9.60.7.0   MAIN                                                              12/22/2023 18:00:40 PAGE 15  

 857   3              break;
 858   3      
 859   3            case 'Z':
 860   3            case 'z':
 861   3                if(argn > 4) {
 862   4                  MonTX(arg[1],arg[2],arg[3],arg[4],arg[5]);
 863   4                  Printf("\r\nTX : %02x %02x %02x %02x %02x %02x", (WORD)arg[1],(WORD)arg[2],(WORD)arg[3],(WORD)arg[4]
             -,(WORD)arg[5]);
 864   4                }
 865   3                else
 866   3                {
 867   4                  Printf("\r\ntoo few parameter!");
 868   4                }
 869   3              break;
 870   3      /*
 871   3            case 't':
 872   3            case 'T':
 873   3              if(argn ==4) {
 874   3      //          NewLine();
 875   3                Montp28xx_byte_write(I2CAddressDeb, 0x40, arg[3]);  
 876   3                delay(1);
 877   3                Montp28xx_byte_write(I2CAddressDeb, arg[1],arg[2]);
 878   3                
 879   3              }
 880   3              
 881   3            
 882   3              break;
 883   3            
 884   3            case 'i':
 885   3            case 'I':
 886   3              if(argn == 3) {
 887   3      //          NewLine();
 888   3                Montp28xx_byte_write(I2CAddressDeb, 0x40, arg[2]);  
 889   3                delay(1);
 890   3                Montp28xx_byte_read(I2CAddressDeb, arg[1]);
 891   3                
 892   3              }
 893   3              break;
 894   3      */      
 895   3            case 'C': /* Change I2C Address */
 896   3            case 'c':
 897   3              if(argn == 2)
 898   3                I2CAddressDeb = arg[1];
 899   3              Printf("\r\nI2C address : %02x", (WORD)I2CAddressDeb);
 900   3              break;
 901   3          
 902   3            
 903   3            case 'H':
 904   3            case 'h':
 905   3            case '?':
 906   3              Usage();
 907   3              break;
 908   3            
 909   3            }
 910   2          
 911   2          Prompt();
 912   2          commdptr = 0;
 913   2          commdbuf[0]='\0';
 914   2        }
 915   1      
 916   1        //----- 1 byte command ----------------------------
 917   1        else {
C51 COMPILER V9.60.7.0   MAIN                                                              12/22/2023 18:00:40 PAGE 16  

 918   2      
 919   2            switch(ikey) {
 920   3      
 921   3            case 0x08:    // back space
 922   3              if(commdptr>0) {
 923   4                commdbuf[commdptr--]='\0';
 924   4                RS_tx(ikey);
 925   4                RS_tx(' ');
 926   4                RS_tx(ikey);
 927   4              }
 928   3              break;
 929   3      
 930   3            case 0x1B:    // Esc 
 931   3              Prompt();
 932   3              commdptr = 0;commdbuf[0]='\0';
 933   3              break;
 934   3      
 935   3            case ',':
 936   3            case '<':
 937   3              RS_tx('\r');
 938   3              MonWriteI2C(I2CAddressDeb, arg[1], --arg[2]);
 939   3              MonReadI2C(I2CAddressDeb, arg[1]);
 940   3      
 941   3              Prompt();
 942   3              commdptr = 0;commdbuf[0]='\0';
 943   3              break;
 944   3      
 945   3            case '.':
 946   3            case '>':
 947   3              RS_tx('\r');
 948   3              MonWriteI2C(I2CAddressDeb, arg[1], ++arg[2]);
 949   3              MonReadI2C(I2CAddressDeb, arg[1]);
 950   3      
 951   3              Prompt();
 952   3              commdptr = 0;commdbuf[0]='\0';
 953   3              break;
 954   3      
 955   3      
 956   3      
 957   3            default:
 958   3              #ifdef TEST_SERCOM
 959   3      
 960   3              if(ikey == '^' || ikey == '$')
 961   3                  MaskEcho = 1;
 962   3      
 963   3              if(!MaskEcho)
 964   3              #endif //TEST_SERCOM
 965   3              
 966   3              RS_tx(ikey);
 967   3              commdbuf[commdptr++] = ikey;
 968   3              break;
 969   3            }
 970   2          
 971   2        }
 972   1      
 973   1      }
 974          
 975          
 976          void InitReset(){
 977   1          int t = tm01;
 978   1      
 979   1          reset = 0;
C51 COMPILER V9.60.7.0   MAIN                                                              12/22/2023 18:00:40 PAGE 17  

 980   1          while(t == tm01);
 981   1          
 982   1      //    delay(1);
 983   1          reset = 1;
 984   1      }
 985          
 986          BYTE SW_Sel_Resolution(){
 987   1      /*  
 988   1        BYTE res,frme,sys,zone;
 989   1        sys = R1080P_n720P;
 990   1        frme = R6050f_n3025f;
 991   1        zone = RNT_nPAL;
 992   1      
 993   1        res = (sys<<2);
 994   1        res |=  (frme<<1);
 995   1        res |=  zone;   
 996   1      
 997   1        return res;*/
 998   1        BYTE tmp;
 999   1      //  tmp = (P1>>5);
1000   1        tmp = (P2>>3)&0x07;
1001   1        if(tmp > 0x03)       ManVidStd = STD_TVI;
1002   1        else                 ManVidStd = STD_HDA;
1003   1        
1004   1        tmp &= 0x03;
1005   1        if(0x00 == tmp)      tmp = TP2802_720P30V2;
1006   1        if(0x01 == tmp)      tmp = TP2802_720P25V2;
1007   1        if(0x02 == tmp)      tmp = TP2802_1080P30;
1008   1        if(0x02 == tmp)      tmp = TP2802_1080P25;  
1009   1        
1010   1        return tmp;
1011   1      }
1012          
1013          void InitRegisterSet()
1014          {
1015   1        
1016   1        ManVidRes = SW_Sel_Resolution();
1017   1        Printf("\r\nManual format = %02x",(WORD)ManVidRes);
1018   1        
1019   1        ManSelCh = (P2>>1)&0x03;
1020   1        Printf("\r\nManual channel = %02x",(WORD)ManSelCh);
1021   1        //IsChannel = ManSelCh;
1022   1      
1023   1        if(0==MD0_2) 
1024   1        {
1025   2          //half_scaler=1;
1026   2          //Printf("\r\nHalf mode enable");
1027   2          en_tvi960p_H1400=1;
1028   2          Printf("\r\nTVI960P 1400X1125 enable");   
1029   2        }
1030   1        
1031   1        if(0==MD0_3)
1032   1        {
1033   2          en_960P=1;
1034   2          Printf("\r\n960P mode enable");
1035   2        }
1036   1        
1037   1        if(0==MD0_0)
1038   1        {
1039   2          BT1120_out=1;
1040   2          Printf("\r\nBT1120 output");
1041   2        }
C51 COMPILER V9.60.7.0   MAIN                                                              12/22/2023 18:00:40 PAGE 18  

1042   1        
1043   1        Init_TP_RegSet();
1044   1      
1045   1        delay(5);
1046   1        Prompt();
1047   1          
1048   1      }
1049          
1050          void Main_Initialize()
1051          {
1052   1      
1053   1        InitCPU();
1054   1        delay(10);
1055   1        
1056   1      //  reset = 0;
1057   1        
1058   1        InitReset();
1059   1        
1060   1        commdptr = 0;
1061   1      //  RS485DE = 0;
1062   1      //  RS485DI = 1;
1063   1      
1064   1        NewLine();
1065   1        delay(10);
1066   1      
1067   1        InitRegisterSet();
1068   1        Usage();
1069   1        delay(10);
1070   1      
1071   1        Prompt();
1072   1      
1073   1      
1074   1      }
1075          
1076          
1077          
1078          /*===========================================================================*/
1079          /*                             MAIN PROGRAM                                  */
1080          /*===========================================================================*/
1081          
1082          void main (void)
1083          {
1084   1      //  int ch;
1085   1        BYTE status,i;
1086   1      
1087   1        Main_Initialize();
1088   1      
1089   1        CreateMDIN340VideoInstance();
1090   1        //MDIN340();
1091   1        I2CAddressDeb = TVII2CAddress;
1092   1        while(1) 
1093   1        { 
1094   2          
1095   2          if(RS_ready())          //----- Check Serial Port 
1096   2            DebugKeyIn( RS_rx() );
1097   2      
1098   2          //CheckSwitchEvent();
1099   2        
1100   2          if(timeout) 
1101   2          {
1102   3            wait_5ms(200);
1103   3            if(DetAutoStd) EQ_Detect();
C51 COMPILER V9.60.7.0   MAIN                                                              12/22/2023 18:00:40 PAGE 19  

1104   3            
1105   3            //ReadUTC();
1106   3            //if(BYDtest) 
1107   3            //MonTX(0xFF, 0x55, 0xaa, 0x0f, 0xf0);
1108   3          }
1109   2          
1110   2        //  if(!DetAutoStd)
1111   2          //{
1112   2          //  status = tp28xx_byte_read(0x01);
1113   2          //  if(0x7a != status)
1114   2          //    Printf("\r\nReg01 = : %02x", (WORD)status); 
1115   2      
1116   2        //  }
1117   2          
1118   2          ReadUTC();
1119   2          MDIN340();
1120   2      
1121   2        }
1122   1        
1123   1      }
*** WARNING C280 IN LINE 1085 OF src\Main.c: 'status': unreferenced local variable
*** WARNING C280 IN LINE 1085 OF src\Main.c: 'i': unreferenced local variable


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2778    ----
   CONSTANT SIZE    =    854    ----
   XDATA SIZE       =    183      96
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =     14       3
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  5 WARNING(S),  0 ERROR(S)
